# 八股

标签（空格分隔）： C++ 面向对象 STL 计算机网络 操作系统

---

##面向对象

###1.什么是面向对象

> 面向对象是一种编程思想，把一切东西都看成是一个个对象，比如人、耳机等，他们都有各自的属性

###2.面向对象和面向过程的区别 
> 面向过程：根据业务逻辑从上到下写代码
面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

###3.面向对象的三大特性 

> 继承，多态，封装
继承：可以使用原有类的功能的情况下，不需要重新编写原先的类而对功能进行扩展。
封装：隐藏对象的属性和实现细节，仅对外公布接口与对象进行交互。
多态：允许可将不同类型的对象视为同一基类的实例，并根据对象的实际类型动态地调用相应的函数或方法。主要有静态多态（函数重载）和动态多态（函数重写）两种。

###4.重载和重写

> 重载是同一作用域内被声明的几个具有不同参数列表的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。重载是C++通过命名倾轧技术在编译阶段实现的，在编译阶段会把返回类型以及参数类型也带上。

> 重写是指在派生类中被重新定义的函数，这要求函数的名称，返回类型，参数列表全部与基类相同。派生类对象调用时使用派生类的重写函数，基类的被重写函数要带有virtual修饰。这里涉及几个概念，我们代码举例说明


        class Animal {
    public:
        virtual void sound() { cout << "Animal sound" << endl; }
    };
    
    class Dog : public Animal {
    public:
        void sound() override { cout << "Woof!" << endl; }
    };
    
    class Cat : public Animal {
    public:
        void sound() override { cout << "Meow!" << endl; }
    };
    
    int main() {
        Animal* a1 = new Dog();
        Animal* a2 = new Cat();
        a1->sound(); // 输出 "Woof!"
        a2->sound(); // 输出 "Meow!"
        delete a1;
        delete a2;
        return 0;
    }
    // 代码ai生成
    
    

> 这段代码中被重写的函数就是虚函数，使用virtual修饰。我们在main函数中使用了基类指针调用派生类函数，这是因为向上转型（派生类转换为基类）是相对安全的，不存在数据的丢失，而向下转型（基类转换为派生类）则能存在数据的丢失，因为基类的指针或引用的内存可能不包含子类成员的数据。我们能看到实际的输出与对象实际类型相关，这是因为这是一种动态绑定，在运行时根据对象的实际类型选择调用的函数，就是代码中虽然a1,a2都是Animal的指针类型，但实际输出与对象实际类型Dog，Cat相关。

> 这里我们也能看出动态多态的条件：一需要有虚函数，才能重写函数；二通过基类指针或引用来调用虚函数。

###5.虚函数
> 虚函数能被重写的情况有以下三种：
1.正常情况下即函数名称、返回类型、参数列表派生类中函数与基类中虚函数相同，派生类即使不加virtua也构成重写，因为继承后父类的虚函数接口在子类中依旧保持虚函数属性。
2.返回类型是具有父子关系的指针或者引用（这种重写叫协变）。如你在基类中虚函数返回类型为基类类型，而派生类中返回类型为派生类类型。
3.析构函数的重写，只要你基类的析构函数为虚函数，你的派生类的析构函数就是对它的重写。虚析构函数在我们使用一个基类指针绑定派生类对象时十分重要，如果此时没有虚析构函数，那么指针释放时仅会调用基类的析构函数，这会造成资源管理问题。
（4）.注意构造函数不能是虚函数。因为虚函数的实现与虚函数表有关，但虚函数表在对象实例化时生成，二者矛盾。

> 当一个虚函数在基类中只有定义没有实现时，我们将其称之为纯虚函数，包含纯虚函数的类我们称之为抽象类。纯虚函数只有在派生类中实现才能使用。从中我们也能看出虚函数的主要目的就是为了提供一个统一的接口。

> 虚函数的定义不能被static修饰，因为被static修饰的函数要求在编译时在前期绑定（静态），而虚函数是动态绑定。

###6.虚函数表
> 虚函数的实现与虚函数表（vtable）相关。如果一个类有虚函数，那么编译器会为该类生成一个虚函数表，存储在程序的只读数据段。虚函数表是一个函数指针数组，指向某个虚函数的实现，简单来说就是告诉你使用哪个重写的函数。

> 每个包含虚函数类的对象都有个虚函数表指针（vptr）指向该类的虚函数表。

###7.虚继承
> 虚继承与虚函数听起来很像，实际上风马牛不相及。虚继承就是子类中只有一份间接父类的数据。该技术用于解决多继承中的父类为非虚基类时出现的数据冗余问题，即菱形继承问题。菱形继承主要是存在两个问题，一个是消耗了冗余的内存，二个是在调用基类的基类变量时会存在编译报错（不知道调用哪个基类的基类）。而虚继承通过虚基类解决了这个问题，在继承时使用virtual修饰虚基类，这样在派生类再继承时，就不会有重复的内存了，只会存储一份虚基类，使用了虚基类的内存中只会有一个vbptr指向虚基表，虚基表中存储了使用的每个虚基类在派生类中的偏移量。具体可以去查看这篇文章[C++语法——详解虚继承][1]，讲得很好。

###8.构造函数
> 构造函数主要有三种：
默认构造函数和初始化构造函数：在定义类的对象的时候，完成对象的初始化工作。
赋值构造函数：默认实现的是值拷贝（浅拷贝）。
移动构造函数：用于将其他类型的变量，隐式转换为本类对象，使用右指引入（&&）实现。

> 这里注意移动构造一定是浅拷贝，赋值构造默认是浅拷贝，但能通过重载赋值运算符的方式实现深拷贝。刚好讲一下深浅拷贝，浅拷贝本质上源对象与目的对象共用一份实体，只是名字不同，二者的地址实际上是相同的，深拷贝则是新使用了一块相同大小的内存，将内容拷贝了进去。深浅拷贝的主要区别在于内存是否相同。前面说的左值与右值也讲一下，左值是持久的对象，右值是临时不稳定的对象。

###9.final
> final关键字可以表明一个类不能被继承或者一个函数不能被重写。

###10.类模板和模板类
> 类模板是一个通用的类定义，包含类型参数。类模板在编译时不会生成具体的类，直到它被实例化。
模板类是类模板在特定类型参数下的实例化结果。模板类是在类模板被实例化时由编译器生成的具体类。

---
##STL

###1.基本组成部分
> 

---


  [1]: https://blog.csdn.net/weixin_61857742/article/details/127344922?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522fb055cb54d8abe81ae7ecc1cac0f63ad%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=fb055cb54d8abe81ae7ecc1cac0f63ad&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127344922-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=%E8%99%9A%E7%BB%A7%E6%89%BF&spm=1018.2226.3001.4187